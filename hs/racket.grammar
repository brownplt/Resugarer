core

  start Expr

  values
    Value : String -> Expr;
    True : Expr;
    False : Expr;
    Num : String -> Expr;
    Str : String -> Expr;
    Id : String -> Expr;

  constructors
    Lambda : [String] * [Expr] -> Expr;
    Begin : [Expr] -> Expr;
    Set : String * Expr -> Expr;
    If : Expr * Expr * Expr -> Expr;
    Apply : Expr * [Expr] -> Expr;


surface

  start Expr

  values
    Value : String -> Expr;
    True : Expr;
    False : Expr;
    Num : String -> Expr;
    Str : String -> Expr;
    Id : String -> Expr;

    Binding : String * Expr -> Binding;    
	CondCase : Expr * Expr -> CondCase;
	Else : Expr -> CondCase;

    Delay : Expr -> Expr;

  constructors
    Lambda : [String] * [Expr] -> Expr;
    Begin : [Expr] -> Expr;
    Set : String * Expr -> Expr;
    If : Expr * Expr * Expr -> Expr;
    Apply : Expr * [Expr] -> Expr;

 	Inc : Expr -> Expr;
    Let : [Binding] * [Expr] -> Expr;
    Cond : [CondCase] -> Expr;
    Or : [Expr] -> Expr;


rules
  Delay(x) -> Apply(Lambda([], [x]), []);

  Inc(x) -> Apply(Id("+"), [x, Num("1")]);
  Let([Binding(v, b)], [x ...]) ->
    Apply(Lambda([v], [x ...]), [b]);
  Let([Binding(v, b), bs ...], x) ->
    Apply(Lambda([v], [!Let([bs ...], x)]), [b]);
  Cond([]) -> Apply(Id("void"), []);
  Cond([Else(x)]) -> x;
  Cond([CondCase(x, y), cs ...]) ->
    If(x, y, !Cond([cs ...]));
  Or([x]) -> Delay(x);
  Or([x, xs ...]) ->
    Let([Binding("t", x)], [If(Id("t"), Id("t"), !Or([xs ...]))]);
