core

  start Expr

  values
    Value : String -> Expr;
    True : Expr;
    False : Expr;
    Num : String -> Expr;
    Str : String -> Expr;
    Id : String -> Expr;

  constructors
    Lambda : [String] * [Expr] -> Expr;
    Begin : [Expr] -> Expr;
    Set : String * Expr -> Expr;
    If : Expr * Expr * Expr -> Expr;
    Apply : Expr * [Expr] -> Expr;


surface

  start Expr

  values
    SValue : String -> Expr;
    STrue : Expr;
    SFalse : Expr;
    SNum : String -> Expr;
    SStr : String -> Expr;
    SId : String -> Expr;

    Binding : String * Expr -> Binding;    
	CondCase : Expr * Expr -> CondCase;
	Else : Expr -> CondCase;

    Delay : Expr -> Expr;

  constructors
    SLambda : [String] * [Expr] -> Expr;
    SBegin : [Expr] -> Expr;
    SSet : String * Expr -> Expr;
    SIf : Expr * Expr * Expr -> Expr;
    SApply : Expr * [Expr] -> Expr;

 	Inc : Expr -> Expr;
    Let : [Binding] * [Expr] -> Expr;
    Cond : [CondCase] -> Expr;
    Or : [Expr] -> Expr;


rules

  SValue(x) -> Value(x);
  STrue -> True;
  SFalse -> False;
  SNum(x) -> Num(x);
  SId(x) -> Id(x);
  SStr(x) -> Str(x);

  SLambda(v, x) -> Lambda(v, x);
  SBegin(x) -> Begin(x);
  SSet(v, x) -> Set(v, x);
  SIf(x, y, z) -> If(x, y, z);
  SApply(f, x) -> Apply(f, x);

  Delay(x) -> Apply(Lambda([], [x]), []);

  Inc(x) -> Apply(Id("+"), [x, Num("1")]);
  Let([Binding(v, b)], [x ...]) ->
    Apply(Lambda([v], [x ...]), [b]);
  Let([Binding(v, b), bs ...], x) ->
    Apply(Lambda([v], [!Let([bs ...], x)]), [b]);
  Cond([]) -> Apply(Id("void"), []);
  Cond([Else(x)]) -> x;
  Cond([CondCase(x, y), cs ...]) ->
    If(x, y, !Cond([cs ...]));
  Or([x]) -> Delay(x);
  Or([x, xs ...]) ->
    Let([Binding("t", x)], [If(Id("t"), Id("t"), !Or([xs ...]))]);
