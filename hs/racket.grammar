core

  start CExpr

  values
    Value : String -> CExpr;
    True : CExpr;
    False : CExpr;
    Num : String -> CExpr;
    Str : String -> CExpr;
    Id : String -> CExpr;

  constructors
    Lambda : [String] * [CExpr] -> CExpr;
    Begin : [CExpr] -> CExpr;
    Set : String * CExpr -> CExpr;
    If : CExpr * CExpr * CExpr -> CExpr;
    Apply : CExpr * [CExpr] -> CExpr;


surface

  start SExpr

  values
    Value : String -> SExpr;
    True : SExpr;
    False : SExpr;
    Num : String -> SExpr;
    Str : String -> SExpr;
    Id : String -> SExpr;

    Binding : String * SExpr -> Binding;    
	CondCase : SExpr * SExpr -> CondCase;
	Else : SExpr -> CondCase;

    Delay : SExpr -> SExpr;

  constructors
    Lambda : [String] * [SExpr] -> SExpr;
    Begin : [SExpr] -> SExpr;
    Set : String * SExpr -> SExpr;
    If : SExpr * SExpr * SExpr -> SExpr;
    Apply : SExpr * [SExpr] -> SExpr;

 	Inc : SExpr -> SExpr;
    Let : [Binding] * [SExpr] -> SExpr;
    Cond : [CondCase] -> SExpr;
    Or : [SExpr] -> SExpr;


rules

  Delay(x) -> Apply(Lambda([], [x]), []);

  Inc(x) -> Apply(Id("+"), [x, Num("1")]);
  Let([Binding(v, b)], [x ...]) ->
    Apply(Lambda([v], [x ...]), [b]);
  Let([Binding(v, b), bs ...], x) ->
    Apply(Lambda([v], [!Let([bs ...], x)]), [b]);
  Cond([]) -> Apply(Id("void"), []);
  Cond([Else(x)]) -> x;
  Cond([CondCase(x, y), cs ...]) ->
    If(x, y, !Cond([cs ...]));
  Or([x]) -> Delay(x);
  Or([x, xs ...]) ->
    Let([Binding("t", x)], [If(Id("t"), Id("t"), !Or([xs ...]))]);
